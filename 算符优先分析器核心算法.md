# 算符优先分析器核心算法

## 1、获取访问集合

1. ### 获取访问集合的核心算法(getAccessMap)

   ```java
     /**
        * .
        * 获取文法的访问集合
        *
        * @param grammarMap     文法集合
        * @param noEndCharacter 非终结符
        * @param accessSet      访问集合
        * @param type           获取的集合类型
        */
       @Override
       public void getAccessMap(HashMap<Character, HashSet<String>> grammarMap, Character noEndCharacter, HashSet<String> accessSet, int type) {
           // 获取当前非终结符的产生式集合;
           HashSet<String> hashSet = grammarMap.get(noEndCharacter);
           // 声明当前访问到的第一个字符变量;
           char currentCharacter;
           // 声明当前的非终结符;
           char currentNoEndCharacter;
           // 遍历当前的产生式
           for (String s : hashSet) {
               // 判断当前的访问类型是否为FIRST VT集合
               if (type == 0) {
                   // 初始化第一个访问到的字符
                   currentCharacter = s.charAt(0);
                   // 如果当前产生式的第一个元素为终结符
                   if (Grammar.isVT(currentCharacter)) {
                       // 那就将他加入访问集合
                       accessSet.add(String.valueOf(currentCharacter));
                       // 直接跳过当前产生式;
                       continue;
                   } else if (Grammar.isVN(currentCharacter)) {
                       // 初始化当前非终结符
                       currentNoEndCharacter = currentCharacter;
                       // 遍历当前产生式的所有元素
                       for (int i = 1; i < s.length(); i++) {
                           // 获取当前的产生式的元素;
                           currentCharacter = s.charAt(i);
                           // 如果当前元素为终结符
                           if (Grammar.isVT(currentCharacter)) {
                               // 那就将他加入访问集合元素
                               accessSet.add(String.valueOf(currentCharacter));
                               // 然后结束当前循环
                               break;
                           }
                       }
                       // 判断当前的非终结符是否和开始符号相同
                       if (currentNoEndCharacter == noEndCharacter) {
                           // 如果是的话，直接跳过当前产生式;
                           continue;
                       }
                       // 否则的话继续求该非终结符的访问集合并传递当前获取到的非终结符访问集合中;
                       getAccessMap(grammarMap, currentNoEndCharacter, accessSet, type);
                   }
               }
               // 获取LAST VT 集合
               if (type == -1) {
                   // 初始化第一个访问到的字符
                   currentCharacter = s.charAt(s.length() - 1);
                   // 如果当前产生式的第一个元素为终结符
                   if (Grammar.isVT(currentCharacter)) {
                       // 那就将他加入访问集合
                       accessSet.add(String.valueOf(currentCharacter));
                       // 判断当前元素是否为非终结符
                   } else if (Grammar.isVN(currentCharacter)) {
                       // 初始化当前非终结符
                       currentNoEndCharacter = currentCharacter;
                       // 遍历当前产生式的所有元素从后往前遍历
                       for (int i = s.length() - 2; i >= 0; i--) {
                           // 获取当前的产生式的元素;
                           currentCharacter = s.charAt(i);
                           // 如果当前元素为终结符
                           if (Grammar.isVT(currentCharacter)) {
                               // 那就将他加入访问集合元素
                               accessSet.add(String.valueOf(currentCharacter));
                               // 然后结束当前循环
                               break;
                           }
                       }
                       // 如果当前非终结符是开始非终结符
                       if (currentNoEndCharacter == noEndCharacter) {
                           // 那就直接跳过
                           continue;
                       }
                       // 然后传递当前获取到的非终结符;
                       getAccessMap(grammarMap, currentNoEndCharacter, accessSet, type);
                   }
               }
           }
       }
   
   ```

   

2. ### 获取FIRST VT集合

   ```java
    /**
        * .
        * 获取当前FIRST VT集合;
        *
        * @return 当前文法的所有的firstVT元素;
        */
       @Override
       public HashMap<Character, HashSet<String>> getFistVt() {
           // 初始化访问结果的FIRST VT 集合
           HashMap<Character, HashSet<String>> firstVTSet = new HashMap<>();
           // 设置当前非终结符的首先访问集合;
           HashSet<String> resultSet = new HashSet<>();
           // 遍历文法的开始符号;
           for (Character character : Grammar.RESULT_MAP.keySet()) {
               // 调用方法，获取访问集合 参数为文法集合，当前开始符号，当前集合已知的集合，访问类型(0/-1);
               operatorOperation.getAccessMap(Grammar.RESULT_MAP, character, resultSet, 0);
               // 获取后，将的当前文法的首先访问集合加入结果集合
               firstVTSet.put(character, resultSet);
               // 上传后重新清空列表
               resultSet = new HashSet<>();
           }
           // 返回当前文法的FIRST VT 集合;
           return firstVTSet;
       }
   ```

3. ### 获取LAST VT 集合

   ```java
       /**
        * .
        * 获取当前LAST VT集合;
        *
        * @return 当前文法的所有的LAST VT元素;
        */
       @Override
       public HashMap<Character, HashSet<String>> getLastVt() {
           // 设置当前的LAST VT集合;
           HashMap<Character, HashSet<String>> lastVTSet = new HashMap<>();
           // 设置当前非终结符的首先访问集合;
           HashSet<String> resultSet = new HashSet<>();
           // 遍历文法的开始符号;
           for (Character character : Grammar.RESULT_MAP.keySet()) {
               // 调用方法，获取访问集合 参数为文法集合，当前开始符号，当前集合已知的集合，访问类型(0/-1);
               operatorOperation.getAccessMap(Grammar.RESULT_MAP, character, resultSet, -1);
               // 获取后，将的当前文法的首先访问集合加入结果集合
               lastVTSet.put(character, resultSet);
               // 上传后重新清空列表
               resultSet = new HashSet<>();
           }
           // 返回当前文法的LAST VT 集合
           return lastVTSet;
       }
   ```

## 2、打印优先关系矩阵

1. ### 获取文法的优先关系

   1. #### 优先级高于

      ```java
          /**
           * .
           * 判断当前的非终结符和终结符之间的关系是否为高于
           * R->Pb 若有a ∈ LASTVT(P) ,则a⋗b，则P⋗b
           *
           * @param src 非终结符
           * @param tag 终结符
           * @return 是否大于
           */
          @Override
          public boolean isGreater(char src, char tag) {
              // 获取所有终结符的LAST VT集合;
              HashMap<Character, HashSet<String>> lastVT = OPERATION_ACCESS.getLastVt();
              // 判断当前非终结符是否存在LAST VT 集合;
              if (lastVT.containsKey(src)) {
                  // 如果存在则判断当前非终结符的LAST VT 集合是否为空;
                  if (lastVT.get(src).isEmpty()) {
                      // 如果为空，则表示优先级不高于
                      return false;
                  }
                  // 否则的直接返回false
              } else {
                  return false;
              }
              // 当传递的非终结符的集合不为空的时候，我们就需要判断第二个元素是否为非终结符号，如果是的话，就返回true，其他的默认返回false;
              return Grammar.isVT(tag);
          }
      ```

   2. #### 优先级低于

      ```java
          /**
           * .
           * 判断当前所给第一个元素是否为小于第二个元素
           * 对形如 R-> aP的产生式，若有b ∈ FIRSTVT(P),则a⋖b，a⋖P
           *
           * @param src 第一个元素终结符
           * @param tag 第二个元素非终结符
           * @return 是否小于
           */
          @Override
          public boolean isLess(char src, char tag) {
              // 获取到文法的FIRST VT集合
              HashMap<Character, HashSet<String>> fistVt = OPERATION_ACCESS.getFistVt();
              // 判断当前非终结符的FIST VT集合是否存在
              if (fistVt.containsKey(tag)) {
                  // 获取的非终结符的集合是否为空
                  if (fistVt.get(tag).isEmpty()) {
                      // 如果为空则直接返回false
                      return false;
                  }
                  // 不存在集合则直接返回false
              } else {
                  return false;
              }
              // 如果集合非空，则我们判断第一个符号是否为终结符，如果是的话则返回true，反之亦然
              return Grammar.isVT(src);
          }
      
      ```

   3. #### 优先级相等

      1. ```java
             /**
              * .
              * 判断两个文法元素元素之间优先关系是否相等
              * 对于形如 R->ab,则a ≑ b
              * @param src 文法元素
              * @param tag 文法元素
              * @return 是否相等
              */
             @Override
             public boolean isEquals(char src, char tag) {
                 // 判断当前元素是否为终结符
                 return Grammar.isVT(src) && Grammar.isVT(tag);
             }
         ```

      2. ```java
             /**
              * .
              * 判断两个文法元素元素之间优先关系是否相等
              * 对于形如 R->aQb,则a ≑ b
              * @param src 文法元素
              * @param in  中间元素通常为非终结符
              * @param tag 文法元素
              * @return 是否相等
              */
             @Override
             public boolean isEquals(char src, char in, char tag) {
                 // 判断当前元素是否为终结符
                 if (Grammar.isVT(src) && Grammar.isVT(tag)) {
                     // 判断中间元素是否为非终结符
                     return Grammar.isVN(in);
                 }
                 // 反之为False
                 return false;
             }
         
         ```

         

2. ### 获取文法优先关系集合

   ```java
       /**
        * .
        * 获取当前文法的优先关系
        *
        * @return 存储优先关系的Map集合;
        */
       @Override
       public HashMap<String, String> getGrammarPriorityRelationships() {
           // 创建一个获取访问操作的集合
           OperationAccess operationAccess = new OperationAccessImpl();
           // 创建一个获取第一个文法的开始符号的集合
           HashSet<String> endSet = new HashSet<>();
           endSet.add("#" + Grammar.GRAMMAR_START + "#");
           Grammar.RESULT_MAP.put('#', endSet);
           // 声明当前的产生式元素变量
           char currentElement;
           // 声明下一个产生式元素变量;
           char nextElement;
           // 遍历所有文法的开始符号
           for (Character character : Grammar.RESULT_MAP.keySet()) {
               // 获取对应的产生式
               for (String s : Grammar.RESULT_MAP.get(character)) {
   
                   // 判断当前产生式是否需要比较P->AC
                   if (s.length() >= 2) {
                       // 遍历当前字符串的字符元素
                       for (int i = 0; i < s.length() - 1; i++) {
                           // 初始化当前产生式元素
                           currentElement = s.charAt(i);
                           // 初始化下一个产生式元素
                           nextElement = s.charAt(i + 1);
                           // 判断当前产生式的优先级是否大于下一个
                           if (GRAMMAR_OPERATION.isGreater(currentElement, nextElement)) {
                               // 那就将当前比较的结果加入到结果集合中;
                               HashSet<String> hashSet = operationAccess.getLastVt().get(currentElement);
                               // 格式化文法LASTVT产生式列表字符串转化为连续字符串
                               String s1 = hashSet.toString().replaceAll("\\[", "")
                                       .replaceAll("]", "")
                                       .replaceAll(",", "");
                               // 判别后，上传比较左部元素的LAST VT集合以及右部元素，以及专用符号
                               GRAMMAR_PRIORITY_RELATION_SHIPS.put(s1 + "%" + nextElement, "⋗");
                               continue;
                           }
   
                           // 判断当前产生式的优先级是否小于下一个
                           if (GRAMMAR_OPERATION.isLess(currentElement, nextElement)) {
                               // 将集合中元素替换为字符串
                               HashSet<String> hashSet = operationAccess.getFistVt().get(nextElement);
                               // 格式化文法FIRSTVT产生式列表字符串转化为连续字符串
                               String s1 = hashSet.toString().replaceAll("\\[", "")
                                       .replaceAll("]", "")
                                       .replaceAll(",", "");
                               // 判别后，上传比较左部元素以及右部元素的LAST VT集合，以及专用符号
                               GRAMMAR_PRIORITY_RELATION_SHIPS.put(currentElement + "%" + s1, "⋖");
                           }
                           // 判断当前产生式的优先级是否为普通的相等
                           if (GRAMMAR_OPERATION.isEquals(currentElement, nextElement)) {
                               GRAMMAR_PRIORITY_RELATION_SHIPS.put(currentElement + "%" + nextElement, "≑");
                           }
                       }
                   }
                   // 判断当前产生式是否大于2
                   if (s.length() > 2) {
                       // 重新遍历当前产生式的元素，用于判断是否想等
                       for (int i = 0; i < s.length() - 2; i++) {
                           // 初始化当前元素;
                           currentElement = s.charAt(i);
                           // 初始化下一个元素
                           nextElement = s.charAt(i + 2);
                           // 判断元素是否相等,如果产生式元素的优先级相同
                           if (GRAMMAR_OPERATION.isEquals(currentElement, s.charAt(i + 1), nextElement)) {
                               // 直接上传元素到集合中
                               GRAMMAR_PRIORITY_RELATION_SHIPS.put(currentElement + "  %  " + nextElement, "≑");
                           }
                       }
                   }
               }
           }
           // 返回装有终结符关系的集合
           return GRAMMAR_PRIORITY_RELATION_SHIPS;
       }
   ```

3. ### 打印优先关系表

   ```java
     /**
        * .
        * 展示算赋优先关系表
        *
        * @return 二维数组的优先关系表格
        */
       @Override
       public String[][] ShowPriorityRelationshipTable() {
           // 获取文法的所有开始符号
           Set<Character> characters = Grammar.RESULT_MAP.keySet();
           // 声明产生式变量
           HashSet<String> hashSet;
           // 设置交换集合
           HashSet<String> tempSet = new HashSet<>();
           // 遍历所有产生式左部元素
           for (Character character : characters) {
               // 初始化产生式集合
               hashSet = Grammar.RESULT_MAP.get(character);
               // 遍历产生式元素
               for (String s : hashSet) {
                   // 遍历产生式所有字符元素
                   for (int i = 0; i < s.length(); i++) {
                       // 判断当前元素是否为终结符
                       if (Grammar.isVT(s.charAt(i))) {
                           // 将当前元素加入列表中
                           tempSet.add(String.valueOf(s.charAt(i)));
                       }
                   }
               }
           }
           // 声明结果数组
           PRIORITY_RELATION_SHIPS_TABLE = new String[tempSet.size() + 1][tempSet.size() + 1];
           // 设置临时变量用于累加元素
           int index = 1;
           // 将所有的终结符都加入到数组中
           for (String s : tempSet) {
               // 将当前所有的终结符加入到第一行，从0开始
               PRIORITY_RELATION_SHIPS_TABLE[0][index] = s;
               // 上传以后数组索引前移一位
               index++;
           }
           // 上传完列以后，重新初始化索引
           index = 1;
           // 将终结符追加到列
           for (String s : tempSet) {
               // 将每一个终结符元素追加到每一个行的第一个元素从第一个数组开始，注意数组是从第0个开始
               PRIORITY_RELATION_SHIPS_TABLE[index][0] = s;
               // 上传完了以后索引加一
               index++;
           }
           // 获取优先关系中的所有key
           Set<String> keySet = GRAMMAR_PRIORITY_RELATION_SHIPS.keySet();
           // 声明一个行元素
           String row;
           // 声明一个列元素
           String colum;
           // 声明当前的优先符关系变量
           String value;
           // 设置一个参考数组用来获取元素对应的列坐标
           String[] flag = PRIORITY_RELATION_SHIPS_TABLE[0];
           // 遍历所有的终结符关系
           for (String s : keySet) {
               // 获取行元素 .trim()为String的方法，去除空格
               row = s.split("%")[0].trim();
               // 获取列元素
               colum = s.split("%")[1].trim();
               // 获取当前非终结符关系对应的优先符关系
               value = GRAMMAR_PRIORITY_RELATION_SHIPS.get(s);
               // 遍历分析表
               for (String[] resultArray : PRIORITY_RELATION_SHIPS_TABLE) {
                   // 获取当前元素在第一个数组中的元素位置
                   for (int i = 0; i < row.length(); i++) {
                       // 判断当前的元素对应数组位置;
                       if (String.valueOf(row.charAt(i)).equals(resultArray[0])) {
                           // 遍历对应元素
                           for (int j = 0; j < colum.length(); j++) {
                               // 遍历参考数组
                               for (int k = 0; k < flag.length; k++) {
                                   // 如果当前元素等于参考数组中的元素
                                   if (String.valueOf(colum.charAt(j)).equals(flag[k])) {
                                       // 那么就上传运算符到对应的元素位置;
                                       resultArray[k] = value;
                                   }
                               }
                           }
                       }
                   }
               }
           }
           // 遍历所有的数组
           for (String[] resultArray : PRIORITY_RELATION_SHIPS_TABLE) {
               // 遍历数组中的元素
               for (int i = 0; i < resultArray.length; i++) {
                   // 如果当前的元素为空
                   if (resultArray[i] == null) {
                       // 那么就将其替换为空格
                       resultArray[i] = " ";
                   }
               }
           }
           // 替换后返回优先关系表
           return PRIORITY_RELATION_SHIPS_TABLE;
       }
   ```

   

​     

